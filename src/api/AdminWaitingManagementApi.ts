/**
 * Qa admin api
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: admin
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../model/models';
import { BASE_PATH }                                         from '../variables';
import { Configuration }                                     from '../configuration';

/* tslint:disable:no-unused-variable member-ordering */


@Injectable()
export class AdminWaitingManagementApi {
    protected basePath = 'http://hostme-services-qa.azurewebsites.net';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
    }

    /**
     * 
     * 
     * @param restaurantId 
     * @param conf 
     */
    public addConfirmedWaiting(restaurantId: number, conf: models.PanelConfirmation, extraHttpRequestParams?: any): Observable<models.WaitingItem> {
        return this.addConfirmedWaitingWithHttpInfo(restaurantId, conf, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Adds new waiting item
     * Preregister customer for the specified restaurant and returns waiting record with Confirmation Code. Use this method when  customer is going to use HostMe mobile application.  This registration requires customer confirmation by entering confirmation number.
     * @param restaurantId Identifier of the restaurant registered in our system
     */
    public addNewWaiting(restaurantId: number, extraHttpRequestParams?: any): Observable<models.WaitingItem> {
        return this.addNewWaitingWithHttpInfo(restaurantId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Calls waiting party.
     * When table is ready hostess originates Call event. It notifies client that table is ready.
     * @param restaurantId Restaurant identifier
     * @param waitingItemId Waiting item identifier
     * @param tableNumber Number of the table
     */
    public callWaitingParty(restaurantId: number, waitingItemId: number, tableNumber?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.callWaitingPartyWithHttpInfo(restaurantId, waitingItemId, tableNumber, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Closes current waiting position.
     * When person gets a table, hostess should close current position.
     * @param restaurantId Restaurant identifier
     * @param waitingItemId Identifier of the waiting item
     */
    public close(restaurantId: number, waitingItemId: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.closeWithHttpInfo(restaurantId, waitingItemId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Cancels waiting item
     * 
     * @param restaurantId Restaurant identifier
     * @param waitingItemId Waiting item identifier
     * @param origin This parameter specifies who send the message. It could be host or client.
     */
    public closeAsCanceled(restaurantId: number, waitingItemId: number, origin: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.closeAsCanceledWithHttpInfo(restaurantId, waitingItemId, origin, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Sets current waiting record in sited state. When person gets a table, hostess should mark current record as sited.
     * 
     * @param restaurantId Restaurant identifier
     * @param waitingItemId Identifier of the waiting item
     */
    public closeAsSeated(restaurantId: number, waitingItemId: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.closeAsSeatedWithHttpInfo(restaurantId, waitingItemId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Confirms waiting record from HostMe mobile application
     * 
     * @param restaurantId Restaurant identifier
     * @param waitingItemId Waiting item identifier
     * @param conf Confirmation model
     */
    public confirm(restaurantId: number, waitingItemId: number, conf: models.PanelConfirmation, extraHttpRequestParams?: any): Observable<models.WaitingItem> {
        return this.confirmWithHttpInfo(restaurantId, waitingItemId, conf, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Returns all waiting items for the selected restaurant
     * 
     * @param restaurantId Restaurant identifier
     * @param queryOptions OData query
     * @param area 
     * @param groupSize 
     */
    public getAllWaitings(restaurantId: number, queryOptions?: string, area?: string, groupSize?: number, extraHttpRequestParams?: any): Observable<Array<models.WaitingItem>> {
        return this.getAllWaitingsWithHttpInfo(restaurantId, queryOptions, area, groupSize, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param restaurantId 
     * @param waitingItemId 
     */
    public getMessages(restaurantId: number, waitingItemId: number, extraHttpRequestParams?: any): Observable<Array<models.Message>> {
        return this.getMessagesWithHttpInfo(restaurantId, waitingItemId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param restaurantId 
     * @param area 
     */
    public getRestaurantWaitingsStatistic(restaurantId: number, area?: string, extraHttpRequestParams?: any): Observable<models.WaitingsStatistic> {
        return this.getRestaurantWaitingsStatisticWithHttpInfo(restaurantId, area, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param restaurantId 
     */
    public getTodayStats(restaurantId: number, extraHttpRequestParams?: any): Observable<models.WaitingStats> {
        return this.getTodayStatsWithHttpInfo(restaurantId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param restaurantId 
     */
    public getUnreadMessagesCount(restaurantId: number, extraHttpRequestParams?: any): Observable<models.Count> {
        return this.getUnreadMessagesCountWithHttpInfo(restaurantId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Returns waiting item by waiting item identifier
     * 
     * @param restaurantId Restaurant identifier
     * @param waitingItemId Identifier of the waiting item
     */
    public getWaitingById(restaurantId: number, waitingItemId: number, extraHttpRequestParams?: any): Observable<models.WaitingItem> {
        return this.getWaitingByIdWithHttpInfo(restaurantId, waitingItemId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param restaurantId 
     */
    public getWaitingSettings(restaurantId: number, extraHttpRequestParams?: any): Observable<models.WaitingSettings> {
        return this.getWaitingSettingsWithHttpInfo(restaurantId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param restaurantId 
     * @param from 
     * @param to 
     */
    public getWaitingTimeByGroup(restaurantId: number, from?: Date, to?: Date, extraHttpRequestParams?: any): Observable<Array<models.WaitingsStatReportItem>> {
        return this.getWaitingTimeByGroupWithHttpInfo(restaurantId, from, to, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param restaurantId 
     * @param from 
     * @param to 
     */
    public getWaitingTimeByHour(restaurantId: number, from?: Date, to?: Date, extraHttpRequestParams?: any): Observable<Array<models.WaitingsStatReportItem>> {
        return this.getWaitingTimeByHourWithHttpInfo(restaurantId, from, to, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param restaurantId 
     * @param from 
     * @param to 
     */
    public getWaitingTimeByLine(restaurantId: number, from?: Date, to?: Date, extraHttpRequestParams?: any): Observable<Array<models.WaitingsStatReportItem>> {
        return this.getWaitingTimeByLineWithHttpInfo(restaurantId, from, to, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param restaurantId 
     * @param from 
     * @param to 
     */
    public getWaitingTimeByMeal(restaurantId: number, from?: Date, to?: Date, extraHttpRequestParams?: any): Observable<Array<models.WaitingsStatReportItem>> {
        return this.getWaitingTimeByMealWithHttpInfo(restaurantId, from, to, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param restaurantId 
     * @param from 
     * @param to 
     */
    public getWaitingTimeByWeek(restaurantId: number, from?: Date, to?: Date, extraHttpRequestParams?: any): Observable<Array<models.WaitingsStatReportItem>> {
        return this.getWaitingTimeByWeekWithHttpInfo(restaurantId, from, to, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param restaurantId 
     * @param from 
     * @param to 
     */
    public getWaitingTimeByWeekDay(restaurantId: number, from?: Date, to?: Date, extraHttpRequestParams?: any): Observable<Array<models.WaitingsStatReportItem>> {
        return this.getWaitingTimeByWeekDayWithHttpInfo(restaurantId, from, to, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param restaurantId 
     * @param from 
     * @param to 
     */
    public getWaitingsForPeriod(restaurantId: number, from?: Date, to?: Date, extraHttpRequestParams?: any): Observable<Array<models.WaitingReportItem>> {
        return this.getWaitingsForPeriodWithHttpInfo(restaurantId, from, to, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param restaurantId 
     * @param groupBy 
     * @param from 
     * @param to 
     */
    public getWaitingsGroupBy(restaurantId: number, groupBy: string, from?: Date, to?: Date, extraHttpRequestParams?: any): Observable<Array<models.WaitingsStatReportItem>> {
        return this.getWaitingsGroupByWithHttpInfo(restaurantId, groupBy, from, to, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param from 
     * @param to 
     * @param body 
     */
    public incoming(from: string, to: string, body: string, extraHttpRequestParams?: any): Observable<any> {
        return this.incomingWithHttpInfo(from, to, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Marks all message as read.
     * 
     * @param restaurantId Restaurant identifier
     * @param waitingItemId Waiting item identifier
     */
    public markAllMessagesAsRead(restaurantId: number, waitingItemId: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.markAllMessagesAsReadWithHttpInfo(restaurantId, waitingItemId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Puts waiting item, on hold manually
     * 
     * @param restaurantId Restaurant identifier
     * @param waitingItemId Waiting item identifier
     */
    public putOnHold(restaurantId: number, waitingItemId: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.putOnHoldWithHttpInfo(restaurantId, waitingItemId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Reopens closed waiting item
     * 
     * @param restaurantId Restaurant identifier
     * @param waitingItemId Waiting item identifier
     */
    public reOpenWaiting(restaurantId: number, waitingItemId: number, extraHttpRequestParams?: any): Observable<models.WaitingItem> {
        return this.reOpenWaitingWithHttpInfo(restaurantId, waitingItemId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Sends a message related to specified waiting item.
     * 
     * @param restaurantId Restaurant identifier
     * @param waitingItemId Waiting item identifier
     * @param origin This parameter specifies who send the message. It could be host or client.
     * @param createMessage The message with body
     */
    public sendMessage(restaurantId: number, waitingItemId: number, origin: string, createMessage: models.CreateMessage, extraHttpRequestParams?: any): Observable<models.Message> {
        return this.sendMessageWithHttpInfo(restaurantId, waitingItemId, origin, createMessage, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param restaurantId 
     * @param settings 
     */
    public setWaitingSettings(restaurantId: number, settings: models.WaitingSettings, extraHttpRequestParams?: any): Observable<{}> {
        return this.setWaitingSettingsWithHttpInfo(restaurantId, settings, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Sets waiting item off hold
     * 
     * @param restaurantId Restaurant identifier
     * @param waitingItemId Waiting item identifier
     */
    public takeOffHold(restaurantId: number, waitingItemId: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.takeOffHoldWithHttpInfo(restaurantId, waitingItemId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Updates waitingitem
     * 
     * @param restaurantId Identifier of the restaurant registered in our system
     * @param waitingItemId Identifier of the waiting record in our system
     * @param item Update model of waiting record
     */
    public updateWaiting(restaurantId: number, waitingItemId: number, item: models.UpdateWaitingItem, extraHttpRequestParams?: any): Observable<models.WaitingItem> {
        return this.updateWaitingWithHttpInfo(restaurantId, waitingItemId, item, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }


    /**
     * 
     * 
     * @param restaurantId 
     * @param conf 
     */
    public addConfirmedWaitingWithHttpInfo(restaurantId: number, conf: models.PanelConfirmation, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/waitings/confirmed`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling addConfirmedWaiting.');
        }
        // verify required parameter 'conf' is not null or undefined
        if (conf === null || conf === undefined) {
            throw new Error('Required parameter conf was null or undefined when calling addConfirmedWaiting.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml', 
            'application/x-www-form-urlencoded', 
            'image/jpg', 
            'image/jpeg', 
            'image/png'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            

        headers.set('Content-Type', 'application/json');


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: conf == null ? '' : JSON.stringify(conf), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * Adds new waiting item
     * Preregister customer for the specified restaurant and returns waiting record with Confirmation Code. Use this method when  customer is going to use HostMe mobile application.  This registration requires customer confirmation by entering confirmation number.
     * @param restaurantId Identifier of the restaurant registered in our system
     */
    public addNewWaitingWithHttpInfo(restaurantId: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/waitings`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling addNewWaiting.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * Calls waiting party.
     * When table is ready hostess originates Call event. It notifies client that table is ready.
     * @param restaurantId Restaurant identifier
     * @param waitingItemId Waiting item identifier
     * @param tableNumber Number of the table
     */
    public callWaitingPartyWithHttpInfo(restaurantId: number, waitingItemId: number, tableNumber?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/waitings/${waitingItemId}/call`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling callWaitingParty.');
        }
        // verify required parameter 'waitingItemId' is not null or undefined
        if (waitingItemId === null || waitingItemId === undefined) {
            throw new Error('Required parameter waitingItemId was null or undefined when calling callWaitingParty.');
        }
        if (tableNumber !== undefined) {
            queryParameters.set('tableNumber', <any>tableNumber);
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * Closes current waiting position.
     * When person gets a table, hostess should close current position.
     * @param restaurantId Restaurant identifier
     * @param waitingItemId Identifier of the waiting item
     */
    public closeWithHttpInfo(restaurantId: number, waitingItemId: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/waitings/${waitingItemId}/close`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling close.');
        }
        // verify required parameter 'waitingItemId' is not null or undefined
        if (waitingItemId === null || waitingItemId === undefined) {
            throw new Error('Required parameter waitingItemId was null or undefined when calling close.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * Cancels waiting item
     * 
     * @param restaurantId Restaurant identifier
     * @param waitingItemId Waiting item identifier
     * @param origin This parameter specifies who send the message. It could be host or client.
     */
    public closeAsCanceledWithHttpInfo(restaurantId: number, waitingItemId: number, origin: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/waitings/${waitingItemId}/cancel`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling closeAsCanceled.');
        }
        // verify required parameter 'waitingItemId' is not null or undefined
        if (waitingItemId === null || waitingItemId === undefined) {
            throw new Error('Required parameter waitingItemId was null or undefined when calling closeAsCanceled.');
        }
        // verify required parameter 'origin' is not null or undefined
        if (origin === null || origin === undefined) {
            throw new Error('Required parameter origin was null or undefined when calling closeAsCanceled.');
        }
        if (origin !== undefined) {
            queryParameters.set('origin', <any>origin);
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * Sets current waiting record in sited state. When person gets a table, hostess should mark current record as sited.
     * 
     * @param restaurantId Restaurant identifier
     * @param waitingItemId Identifier of the waiting item
     */
    public closeAsSeatedWithHttpInfo(restaurantId: number, waitingItemId: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/waitings/${waitingItemId}/sited`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling closeAsSeated.');
        }
        // verify required parameter 'waitingItemId' is not null or undefined
        if (waitingItemId === null || waitingItemId === undefined) {
            throw new Error('Required parameter waitingItemId was null or undefined when calling closeAsSeated.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * Confirms waiting record from HostMe mobile application
     * 
     * @param restaurantId Restaurant identifier
     * @param waitingItemId Waiting item identifier
     * @param conf Confirmation model
     */
    public confirmWithHttpInfo(restaurantId: number, waitingItemId: number, conf: models.PanelConfirmation, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/waitings/${waitingItemId}/confirm`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling confirm.');
        }
        // verify required parameter 'waitingItemId' is not null or undefined
        if (waitingItemId === null || waitingItemId === undefined) {
            throw new Error('Required parameter waitingItemId was null or undefined when calling confirm.');
        }
        // verify required parameter 'conf' is not null or undefined
        if (conf === null || conf === undefined) {
            throw new Error('Required parameter conf was null or undefined when calling confirm.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml', 
            'application/x-www-form-urlencoded', 
            'image/jpg', 
            'image/jpeg', 
            'image/png'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            

        headers.set('Content-Type', 'application/json');


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: conf == null ? '' : JSON.stringify(conf), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * Returns all waiting items for the selected restaurant
     * 
     * @param restaurantId Restaurant identifier
     * @param queryOptions OData query
     * @param area 
     * @param groupSize 
     */
    public getAllWaitingsWithHttpInfo(restaurantId: number, queryOptions?: string, area?: string, groupSize?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/waitings`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling getAllWaitings.');
        }
        if (queryOptions !== undefined) {
            queryParameters.set('queryOptions', <any>queryOptions);
        }
        if (area !== undefined) {
            queryParameters.set('area', <any>area);
        }
        if (groupSize !== undefined) {
            queryParameters.set('groupSize', <any>groupSize);
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param restaurantId 
     * @param waitingItemId 
     */
    public getMessagesWithHttpInfo(restaurantId: number, waitingItemId: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/waitings/${waitingItemId}/messages`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling getMessages.');
        }
        // verify required parameter 'waitingItemId' is not null or undefined
        if (waitingItemId === null || waitingItemId === undefined) {
            throw new Error('Required parameter waitingItemId was null or undefined when calling getMessages.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param restaurantId 
     * @param area 
     */
    public getRestaurantWaitingsStatisticWithHttpInfo(restaurantId: number, area?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/waitings/stats`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling getRestaurantWaitingsStatistic.');
        }
        if (area !== undefined) {
            queryParameters.set('area', <any>area);
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param restaurantId 
     */
    public getTodayStatsWithHttpInfo(restaurantId: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/stats`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling getTodayStats.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param restaurantId 
     */
    public getUnreadMessagesCountWithHttpInfo(restaurantId: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/waitings/messages/unread/count`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling getUnreadMessagesCount.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * Returns waiting item by waiting item identifier
     * 
     * @param restaurantId Restaurant identifier
     * @param waitingItemId Identifier of the waiting item
     */
    public getWaitingByIdWithHttpInfo(restaurantId: number, waitingItemId: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/waitings/${waitingItemId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling getWaitingById.');
        }
        // verify required parameter 'waitingItemId' is not null or undefined
        if (waitingItemId === null || waitingItemId === undefined) {
            throw new Error('Required parameter waitingItemId was null or undefined when calling getWaitingById.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param restaurantId 
     */
    public getWaitingSettingsWithHttpInfo(restaurantId: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/settings`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling getWaitingSettings.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param restaurantId 
     * @param from 
     * @param to 
     */
    public getWaitingTimeByGroupWithHttpInfo(restaurantId: number, from?: Date, to?: Date, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/analytics/waitings/groupby/partysize`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling getWaitingTimeByGroup.');
        }
        if (from !== undefined) {
            queryParameters.set('from', <any>from);
        }
        if (to !== undefined) {
            queryParameters.set('to', <any>to);
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param restaurantId 
     * @param from 
     * @param to 
     */
    public getWaitingTimeByHourWithHttpInfo(restaurantId: number, from?: Date, to?: Date, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/analytics/waitings/groupby/hour`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling getWaitingTimeByHour.');
        }
        if (from !== undefined) {
            queryParameters.set('from', <any>from);
        }
        if (to !== undefined) {
            queryParameters.set('to', <any>to);
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param restaurantId 
     * @param from 
     * @param to 
     */
    public getWaitingTimeByLineWithHttpInfo(restaurantId: number, from?: Date, to?: Date, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/analytics/waitings/waitings/groupby/line`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling getWaitingTimeByLine.');
        }
        if (from !== undefined) {
            queryParameters.set('from', <any>from);
        }
        if (to !== undefined) {
            queryParameters.set('to', <any>to);
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param restaurantId 
     * @param from 
     * @param to 
     */
    public getWaitingTimeByMealWithHttpInfo(restaurantId: number, from?: Date, to?: Date, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/analytics/waitings/groupby/mealtype`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling getWaitingTimeByMeal.');
        }
        if (from !== undefined) {
            queryParameters.set('from', <any>from);
        }
        if (to !== undefined) {
            queryParameters.set('to', <any>to);
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param restaurantId 
     * @param from 
     * @param to 
     */
    public getWaitingTimeByWeekWithHttpInfo(restaurantId: number, from?: Date, to?: Date, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/analytics/waitings/groupby/week`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling getWaitingTimeByWeek.');
        }
        if (from !== undefined) {
            queryParameters.set('from', <any>from);
        }
        if (to !== undefined) {
            queryParameters.set('to', <any>to);
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param restaurantId 
     * @param from 
     * @param to 
     */
    public getWaitingTimeByWeekDayWithHttpInfo(restaurantId: number, from?: Date, to?: Date, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/analytics/waitings/groupby/weekday`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling getWaitingTimeByWeekDay.');
        }
        if (from !== undefined) {
            queryParameters.set('from', <any>from);
        }
        if (to !== undefined) {
            queryParameters.set('to', <any>to);
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param restaurantId 
     * @param from 
     * @param to 
     */
    public getWaitingsForPeriodWithHttpInfo(restaurantId: number, from?: Date, to?: Date, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/analytics/waitings`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling getWaitingsForPeriod.');
        }
        if (from !== undefined) {
            queryParameters.set('from', <any>from);
        }
        if (to !== undefined) {
            queryParameters.set('to', <any>to);
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param restaurantId 
     * @param groupBy 
     * @param from 
     * @param to 
     */
    public getWaitingsGroupByWithHttpInfo(restaurantId: number, groupBy: string, from?: Date, to?: Date, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/analytics/waitings/groupby`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling getWaitingsGroupBy.');
        }
        // verify required parameter 'groupBy' is not null or undefined
        if (groupBy === null || groupBy === undefined) {
            throw new Error('Required parameter groupBy was null or undefined when calling getWaitingsGroupBy.');
        }
        if (groupBy !== undefined) {
            queryParameters.set('groupBy', <any>groupBy);
        }
        if (from !== undefined) {
            queryParameters.set('from', <any>from);
        }
        if (to !== undefined) {
            queryParameters.set('to', <any>to);
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param from 
     * @param to 
     * @param body 
     */
    public incomingWithHttpInfo(from: string, to: string, body: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/smsclient/incoming`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'from' is not null or undefined
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling incoming.');
        }
        // verify required parameter 'to' is not null or undefined
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling incoming.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling incoming.');
        }
        if (from !== undefined) {
            queryParameters.set('from', <any>from);
        }
        if (to !== undefined) {
            queryParameters.set('to', <any>to);
        }
        if (body !== undefined) {
            queryParameters.set('body', <any>body);
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * Marks all message as read.
     * 
     * @param restaurantId Restaurant identifier
     * @param waitingItemId Waiting item identifier
     */
    public markAllMessagesAsReadWithHttpInfo(restaurantId: number, waitingItemId: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/waitings/${waitingItemId}/messages/readall`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling markAllMessagesAsRead.');
        }
        // verify required parameter 'waitingItemId' is not null or undefined
        if (waitingItemId === null || waitingItemId === undefined) {
            throw new Error('Required parameter waitingItemId was null or undefined when calling markAllMessagesAsRead.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * Puts waiting item, on hold manually
     * 
     * @param restaurantId Restaurant identifier
     * @param waitingItemId Waiting item identifier
     */
    public putOnHoldWithHttpInfo(restaurantId: number, waitingItemId: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/waitings/${waitingItemId}/putonhold`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling putOnHold.');
        }
        // verify required parameter 'waitingItemId' is not null or undefined
        if (waitingItemId === null || waitingItemId === undefined) {
            throw new Error('Required parameter waitingItemId was null or undefined when calling putOnHold.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * Reopens closed waiting item
     * 
     * @param restaurantId Restaurant identifier
     * @param waitingItemId Waiting item identifier
     */
    public reOpenWaitingWithHttpInfo(restaurantId: number, waitingItemId: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/waitings/${waitingItemId}/reopen`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling reOpenWaiting.');
        }
        // verify required parameter 'waitingItemId' is not null or undefined
        if (waitingItemId === null || waitingItemId === undefined) {
            throw new Error('Required parameter waitingItemId was null or undefined when calling reOpenWaiting.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * Sends a message related to specified waiting item.
     * 
     * @param restaurantId Restaurant identifier
     * @param waitingItemId Waiting item identifier
     * @param origin This parameter specifies who send the message. It could be host or client.
     * @param createMessage The message with body
     */
    public sendMessageWithHttpInfo(restaurantId: number, waitingItemId: number, origin: string, createMessage: models.CreateMessage, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/waitings/${waitingItemId}/sendmessage`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling sendMessage.');
        }
        // verify required parameter 'waitingItemId' is not null or undefined
        if (waitingItemId === null || waitingItemId === undefined) {
            throw new Error('Required parameter waitingItemId was null or undefined when calling sendMessage.');
        }
        // verify required parameter 'origin' is not null or undefined
        if (origin === null || origin === undefined) {
            throw new Error('Required parameter origin was null or undefined when calling sendMessage.');
        }
        // verify required parameter 'createMessage' is not null or undefined
        if (createMessage === null || createMessage === undefined) {
            throw new Error('Required parameter createMessage was null or undefined when calling sendMessage.');
        }
        if (origin !== undefined) {
            queryParameters.set('origin', <any>origin);
        }


        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml', 
            'application/x-www-form-urlencoded', 
            'image/jpg', 
            'image/jpeg', 
            'image/png'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            

        headers.set('Content-Type', 'application/json');


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: createMessage == null ? '' : JSON.stringify(createMessage), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param restaurantId 
     * @param settings 
     */
    public setWaitingSettingsWithHttpInfo(restaurantId: number, settings: models.WaitingSettings, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/settings`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling setWaitingSettings.');
        }
        // verify required parameter 'settings' is not null or undefined
        if (settings === null || settings === undefined) {
            throw new Error('Required parameter settings was null or undefined when calling setWaitingSettings.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml', 
            'application/x-www-form-urlencoded', 
            'image/jpg', 
            'image/jpeg', 
            'image/png'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            

        headers.set('Content-Type', 'application/json');


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: settings == null ? '' : JSON.stringify(settings), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * Sets waiting item off hold
     * 
     * @param restaurantId Restaurant identifier
     * @param waitingItemId Waiting item identifier
     */
    public takeOffHoldWithHttpInfo(restaurantId: number, waitingItemId: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/waitings/${waitingItemId}/takeoffhold`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling takeOffHold.');
        }
        // verify required parameter 'waitingItemId' is not null or undefined
        if (waitingItemId === null || waitingItemId === undefined) {
            throw new Error('Required parameter waitingItemId was null or undefined when calling takeOffHold.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

    /**
     * Updates waitingitem
     * 
     * @param restaurantId Identifier of the restaurant registered in our system
     * @param waitingItemId Identifier of the waiting record in our system
     * @param item Update model of waiting record
     */
    public updateWaitingWithHttpInfo(restaurantId: number, waitingItemId: number, item: models.UpdateWaitingItem, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/api/wm/admin/restaurant/${restaurantId}/waitings/${waitingItemId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'restaurantId' is not null or undefined
        if (restaurantId === null || restaurantId === undefined) {
            throw new Error('Required parameter restaurantId was null or undefined when calling updateWaiting.');
        }
        // verify required parameter 'waitingItemId' is not null or undefined
        if (waitingItemId === null || waitingItemId === undefined) {
            throw new Error('Required parameter waitingItemId was null or undefined when calling updateWaiting.');
        }
        // verify required parameter 'item' is not null or undefined
        if (item === null || item === undefined) {
            throw new Error('Required parameter item was null or undefined when calling updateWaiting.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml', 
            'application/x-www-form-urlencoded', 
            'image/jpg', 
            'image/jpeg', 
            'image/png'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'text/json', 
            'application/xml', 
            'text/xml'
        ];
        
        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            

        headers.set('Content-Type', 'application/json');


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: item == null ? '' : JSON.stringify(item), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            responseType: ResponseContentType.Json
        });

        return this.http.request(path, requestOptions);
    }

}
